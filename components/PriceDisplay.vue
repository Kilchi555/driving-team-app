<!-- PriceDisplay.vue - Grundlegende Version -->
<template>
  <div class="space-y-4">
    <!-- Grundpreis -->
    <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
      <h3 class="text-lg font-semibold text-blue-800 mb-3">Preisübersicht</h3>
      <div class="space-y-2">
        <div class="flex justify-between">
          <span class="text-gray-700">{{ lessonType || 'Grundpreis' }} ({{ durationMinutes }} min)</span>
          <span class="font-semibold text-gray-700">CHF {{ getBasePrice().toFixed(2) }}</span>
        </div>
        
        <!-- Rabatt Anzeige - direkt im blauen Bereich -->
        <div v-if="getDiscountAmount() > 0" class="flex justify-between items-center py-2 border-t border-blue-200">
          <div class="flex items-center">
            <span class="text-sm font-medium text-green-700">Rabatt</span>
            <span v-if="getDiscountReason()" class="text-xs text-green-600 ml-2">({{ getDiscountReason() }})</span>
          </div>
          <div class="flex items-center space-x-2">
            <span class="text-sm font-bold text-green-700">- CHF {{ getDiscountAmount().toFixed(2) }}</span>
            <button 
              v-if="props.allowDiscountEdit"
              @click="removeDiscount"
              class="text-red-500 hover:text-red-700 text-xs ml-2"
            >
              ✕
            </button>
          </div>
        </div>
        
        <!-- Admin-Fee Anzeige -->
        <div v-if="getAdminFee() > 0" class="py-2 border-t border-blue-200">
          <div class="flex justify-between items-center">
            <span class="text-sm font-medium text-orange-700">Administrationsgebühr</span>
            <span class="text-sm font-semibold text-orange-700">CHF {{ getAdminFee().toFixed(2) }}</span>
          </div>
        </div>

        <!-- Student Credit Anzeige -->
        <div v-if="getUsedCredit() > 0 || (props.studentCredit && props.studentCredit.balance_rappen > 0)" class="py-2 border-t border-blue-200">
          <div class="space-y-2">
            <!-- Im Edit-Modus: Zeige das damals verwendete Guthaben -->
            <div v-if="props.isEditMode && getUsedCredit() > 0" class="flex justify-between items-center">
              <span class="text-sm font-medium text-green-600">Guthaben verwendet (damals)</span>
              <span class="text-sm font-semibold text-green-600">- CHF {{ getUsedCredit().toFixed(2) }}</span>
            </div>
            
            <!-- Im Create-Modus: Zeige aktuelles Guthaben -->
            <div v-else-if="!props.isEditMode && props.studentCredit && props.studentCredit.balance_rappen > 0" class="flex justify-between items-center">
              <span class="text-sm font-medium text-green-700">Verfügbares Guthaben</span>
              <span class="text-sm font-semibold text-green-700">CHF {{ (props.studentCredit.balance_rappen / 100).toFixed(2) }}</span>
            </div>
            
            <!-- Im Create-Modus: Zeige verwendetes Guthaben -->
            <div v-if="!props.isEditMode && getUsedCredit() > 0" class="flex justify-between items-center">
              <span class="text-sm text-green-600">Guthaben wird verwendet</span>
              <span class="text-sm font-semibold text-green-600">- CHF {{ getUsedCredit().toFixed(2) }}</span>
            </div>
            
            <!-- Im Create-Modus: Zeige verbleibendes Guthaben -->
            <div v-if="!props.isEditMode && props.studentCredit && props.studentCredit.balance_rappen / 100 > getUsedCredit()" class="flex justify-between items-center">
              <span class="text-sm text-green-600">Restguthaben</span>
              <span class="text-sm font-semibold text-green-600">CHF {{ ((props.studentCredit.balance_rappen / 100) - getUsedCredit()).toFixed(2) }}</span>
            </div>
          </div>
        </div>
        
        <!-- Loading State für Guthaben -->
        <div v-else-if="props.isLoadingCredit" class="py-2 border-t border-blue-200">
          <div class="flex justify-between items-center">
            <span class="text-sm text-gray-500">Guthaben wird geladen...</span>
            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500"></div>
          </div>
        </div>
        
        <!-- Kein Guthaben verfügbar -->
        <div v-else-if="props.studentCredit && props.studentCredit.balance_rappen === 0" class="py-2 border-t border-blue-200">
          <div class="flex justify-between items-center">
            <span class="text-sm text-gray-500">Verfügbares Guthaben</span>
            <span class="text-sm text-gray-500">CHF 0.00</span>
          </div>
          <div class="mt-1">
            <span class="text-xs text-gray-400">Kein Guthaben verfügbar</span>
          </div>
        </div>
        
        <!-- Kein Guthaben verfügbar (Student hat kein Guthaben) -->
        <div v-else-if="!props.studentCredit && !props.isLoadingCredit" class="py-2 border-t border-blue-200">
          <div class="flex justify-between items-center">
            <span class="text-sm text-gray-500">Verfügbares Guthaben</span>
            <span class="text-sm text-gray-500">CHF 0.00</span>
          </div>
        </div>

        <!-- Produkte Anzeige - direkt im blauen Bereich -->
        <div v-if="getProducts().length > 0" class="py-2 border-t border-blue-200">
          <div class="space-y-2">
            <div class="text-sm font-medium text-blue-700">Produkte</div>
            <div v-for="product in getProducts()" :key="product.id" class="flex justify-between items-center">
              <div class="flex items-center space-x-2">
                <span class="text-sm text-gray-700">{{ product.name }}</span>
                <span v-if="product.quantity > 1" class="text-xs text-gray-500">({{ product.quantity }}x)</span>
              </div>
              <div class="flex items-center space-x-2">
                <span class="text-sm font-semibold text-gray-700">CHF {{ getProductPrice(product).toFixed(2) }}</span>
                <button 
                  v-if="props.allowProductEdit"
                  @click="removeProduct(product.id)"
                  class="text-red-500 hover:text-red-700 text-xs ml-2"
                >
                  ✕
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <div class="border-t pt-2">
          <!-- Preis vor Guthaben (nur anzeigen wenn Guthaben vorhanden) -->
          <div v-if="props.studentCredit && props.studentCredit.balance_rappen > 0" class="flex justify-between text-sm text-gray-500 mb-1">
            <span>Preis vor Guthaben</span>
            <span>CHF {{ calculatePriceBeforeCredit().toFixed(2) }}</span>
          </div>
          
          <!-- Gesamtpreis (nach Guthaben) -->
          <div class="flex justify-between text-lg font-bold">
            <span class="text-gray-700">Zu bezahlen</span>
            <span class="text-blue-600">CHF {{ calculateTotalPrice().toFixed(2) }}</span>
          </div>
          
          <!-- Gratis Info wenn vollständig durch Guthaben gedeckt -->
          <div v-if="props.studentCredit && props.studentCredit.balance_rappen / 100 >= calculatePriceBeforeCredit()" class="text-center mt-2">
            <span class="text-sm font-medium text-green-600 bg-green-100 px-2 py-1 rounded-full">
              ✅ Vollständig durch Guthaben gedeckt
            </span>
          </div>
        </div>
        
        <!-- Rabatt und Produkte Buttons - zwischen Gesamtpreis und Zahlungsarten -->

        <div v-if="props.allowDiscountEdit || props.allowProductEdit" class="border-t pt-3">
          <div class="flex justify-center space-x-3">
            <!-- ✅ RABATT BUTTON: Immer anzeigen wenn erlaubt -->
            <button
              v-if="props.allowDiscountEdit"
              @click="showDiscountSelector = true"
              class="flex items-center px-4 py-2 text-sm text-purple-600 border border-purple-300 rounded-md hover:bg-purple-50"
            >
              🎫 Rabatt
            </button>
            
            <!-- ✅ PRODUKTE BUTTON: Immer anzeigen wenn erlaubt -->
            <button
              v-if="props.allowProductEdit"
              @click="showProductSelector = true"
              class="flex items-center px-4 py-2 text-sm text-blue-600 border border-blue-300 rounded-md hover:bg-blue-50"
            >
              📦 Produkte
            </button>
          </div>
        </div>
        
        <!-- Produktauswahl Modal - direkt im PriceDisplay -->
        <div v-if="showProductSelector" class="border-t pt-3">
          <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
            
            <div class="space-y-3">
              <!-- Verfügbare Produkte als Kacheln -->
              <div v-if="props.availableProducts && props.availableProducts.length > 0" class="grid grid-cols-2 gap-3">
                <div 
                  v-for="product in props.availableProducts" 
                  :key="product.id" 
                  @click="addProduct(product)"
                  class="bg-white border border-gray-200 rounded-lg p-3 cursor-pointer hover:border-blue-300 hover:shadow-md transition-all duration-200"
                >
                  <div class="text-center space-y-1">
                    <!-- Produkt-Name -->
                    <div class="text-sm font-medium text-gray-700">{{ product.name }}</div>
                    
                    <!-- Produkt-Preis -->
                    <div class="text-sm font-bold text-blue-600">
                      CHF {{ (product.price_rappen / 100).toFixed(2) }}
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Keine Produkte verfügbar -->
              <div v-else class="text-sm text-gray-500 text-center py-4">
                Keine Produkte verfügbar
              </div>
              
              <div class="flex justify-end space-x-3">
                <button
                  @click="showProductSelector = false"
                  class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50"
                >
                  Schließen
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- ✅ RABATT-SELECTOR -->
        <div v-if="showDiscountSelector" class="border-t pt-3">
          <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
            
            <div class="space-y-4">
              
              <!-- Verfügbare Gutscheine -->
              <div v-if="availableDiscounts.length > 0" class="space-y-3">
                <div class="grid grid-cols-2 gap-2">
                  <div 
                    v-for="discount in availableDiscounts" 
                    :key="discount.id" 
                    @click="applyVoucher(discount)"
                    class="bg-white border border-gray-200 rounded-lg p-2 cursor-pointer hover:border-purple-300 hover:shadow-md transition-all duration-200"
                  >
                    <div class="text-center">
                      <div class="text-sm font-bold text-purple-600">
                        - CHF {{ parseFloat(discount.discount_value).toFixed(2) }}
                      </div>
                      <div class="text-xs text-gray-500">{{ discount.name || 'Gutschein' }}</div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="flex justify-end space-x-3 pt-2 border-t border-gray-300">
                <button
                  @click="closeDiscountSelector"
                  class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50"
                >
                  Schließen
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- ✅ NEU: Bestehende Payment-Info anzeigen -->
        <div v-if="showExistingPaymentInfo" class="border-t pt-3">
          <div class="text-sm font-medium text-gray-700 mb-3">Zahlungsinformationen</div>
          <div class="space-y-3">
            <!-- Zahlungsart und Status Badges -->
            <div class="flex items-center gap-2 flex-wrap">
              <!-- Zahlungsart Badge -->
              <span :class="[
                'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium',
                existingPayment?.payment_method === 'wallee' ? 'bg-blue-100 text-blue-800' :
                existingPayment?.payment_method === 'cash' ? 'bg-green-100 text-green-800' :
                existingPayment?.payment_method === 'invoice' ? 'bg-purple-100 text-purple-800' :
                'bg-gray-100 text-gray-800'
              ]">
                {{ existingPayment?.payment_method === 'wallee' ? 'Online-Zahlung' :
                   existingPayment?.payment_method === 'cash' ? 'Bar' :
                   existingPayment?.payment_method === 'invoice' ? 'Rechnung' : 
                   'Unbekannt' }}
              </span>
              
              <!-- Status Badge -->
              <span :class="[
                'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium',
                existingPayment?.payment_status === 'completed' ? 'bg-green-100 text-green-800' :
                existingPayment?.payment_status === 'pending' ? 'bg-yellow-100 text-yellow-800' :
                existingPayment?.payment_status === 'failed' ? 'bg-red-100 text-red-800' :
                'bg-gray-100 text-gray-800'
              ]">
                {{ existingPayment?.payment_status === 'completed' ? 'Bezahlt' :
                   existingPayment?.payment_status === 'pending' ? 'Ausstehend' : 
                   existingPayment?.payment_status === 'failed' ? 'Fehlgeschlagen' :
                   'Unbekannt' }}
              </span>
              
              <!-- Bezahldatum falls vorhanden -->
              <span v-if="existingPayment?.paid_at" class="text-sm text-gray-600">
                bezahlt am {{ new Date(existingPayment.paid_at).toLocaleDateString('de-CH') }}
              </span>
            </div>
            
            <!-- Rechnungsadresse für Invoice -->
            <div v-if="existingPayment?.payment_method === 'invoice' && hasInvoiceAddress" 
                 class="bg-gray-50 p-3 rounded-lg border border-gray-200">
              <div class="text-sm font-medium text-gray-700 mb-2">Rechnungsadresse</div>
              <div class="text-sm text-gray-600 whitespace-pre-line">{{ formatInvoiceAddress() }}</div>
            </div>
          </div>
        </div>

        <!-- Zahlungsarten - nur für neue Termine oder wenn kein Payment existiert -->
        <div v-if="showPaymentSelection && !props.isPastAppointment" class="border-t pt-3">
          <div class="text-sm font-medium text-gray-700 mb-3">Zahlungsart</div>
          
          <!-- ✅ IMMER die schönen Buttons anzeigen -->
          <div class="space-y-3">
            <!-- Online Payment Button -->
            <button
              @click="selectPaymentMethod('wallee')"
              :class="[
                'w-full p-3 rounded-lg border-2 transition-all duration-200 flex items-center justify-center space-x-3',
                selectedPaymentMethod === 'wallee'
                  ? 'border-blue-500 bg-blue-50 text-blue-700 shadow-md'
                  : 'border-gray-200 bg-white text-gray-700 hover:border-blue-300 hover:bg-blue-50'
              ]"
            >
              <span class="font-medium">Online-Zahlung</span>
            </button>
            
            <!-- Cash Payment Button -->
            <button
              @click="selectPaymentMethod('cash')"
              :class="[
                'w-full p-3 rounded-lg border-2 transition-all duration-200 flex items-center justify-center space-x-3',
                selectedPaymentMethod === 'cash'
                  ? 'border-green-500 bg-green-50 text-green-700 shadow-md'
                  : 'border-gray-200 bg-white text-gray-700 hover:border-green-300 hover:bg-green-50'
              ]"
            >
              <span class="font-medium">Bar</span>
            </button>
            
            <!-- Invoice Button -->
            <button
              @click="selectPaymentMethod('invoice')"
              :class="[
                'w-full p-3 rounded-lg border-2 transition-all duration-200 flex items-center justify-center space-x-3',
                selectedPaymentMethod === 'invoice'
                  ? 'border-purple-500 bg-purple-50 text-purple-700 shadow-md'
                  : 'border-gray-200 bg-white text-gray-700 hover:border-purple-300 hover:bg-purple-50'
              ]"
            >
              <span class="font-medium">Rechnung</span>
            </button>
          </div>
        </div>
        
        <!-- ✅ NEU: Gespeicherte Rechnungsadresse anzeigen -->
        <div v-if="shouldShowSavedBillingAddress" class="mt-4 p-3 bg-green-50 rounded-lg border border-green-200">
          <div class="flex justify-between items-start mb-2">
            <h5 class="text-sm font-medium text-gray-700">Gespeicherte Rechnungsadresse</h5>
            <button 
              @click="startEditingBillingAddress"
              class="text-sm text-blue-600 hover:text-blue-800 font-medium"
            >
              ✏️ Bearbeiten
            </button>
          </div>
          
          <!-- Student Billing Address anzeigen -->
          <div v-if="studentBillingAddress" class="text-sm text-gray-600 whitespace-pre-line">
            <div v-if="studentBillingAddress.company_name" class="font-medium">{{ studentBillingAddress.company_name }}</div>
            <div v-if="studentBillingAddress.contact_person">{{ studentBillingAddress.contact_person }}</div>
            <div v-if="studentBillingAddress.email">{{ studentBillingAddress.email }}</div>
            <div v-if="studentBillingAddress.phone">{{ studentBillingAddress.phone }}</div>
            <div v-if="studentBillingAddress.street && studentBillingAddress.street_number">
              {{ studentBillingAddress.street }} {{ studentBillingAddress.street_number }}
            </div>
            <div v-if="studentBillingAddress.zip && studentBillingAddress.city">
              {{ studentBillingAddress.zip }} {{ studentBillingAddress.city }}
            </div>
            <div v-if="studentBillingAddress.country">{{ studentBillingAddress.country }}</div>
          </div>
          
          <!-- Fallback: Existing Payment Billing Address -->
          <div v-else-if="existingPayment?.company_billing_address" class="text-sm text-gray-600">
            <div v-if="existingPayment.company_billing_address.company_name" class="font-medium">{{ existingPayment.company_billing_address.company_name }}</div>
            <div v-if="existingPayment.company_billing_address.contact_person">{{ existingPayment.company_billing_address.contact_person }}</div>
            <div v-if="existingPayment.company_billing_address.email">{{ existingPayment.company_billing_address.email }}</div>
            <div v-if="existingPayment.company_billing_address.phone">{{ existingPayment.company_billing_address.phone }}</div>
            <div v-if="existingPayment.company_billing_address.street && existingPayment.company_billing_address.street_number">
              {{ existingPayment.company_billing_address.street }} {{ existingPayment.company_billing_address.street_number }}
            </div>
            <div v-if="existingPayment.company_billing_address.zip && existingPayment.company_billing_address.city">
              {{ existingPayment.company_billing_address.zip }} {{ existingPayment.company_billing_address.city }}
            </div>
            <div v-if="existingPayment.company_billing_address.country">{{ existingPayment.company_billing_address.country }}</div>
          </div>
        </div>

        <!-- Rechnungsadresse Form - nur wenn Formular angezeigt werden soll -->
        <div v-if="shouldShowBillingAddressForm" class="mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
            <h5 class="text-sm font-medium text-gray-700 mb-3">Rechnungsadresse</h5>
            
            <div class="space-y-3">
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">Firmenname</label>
                <input
                  v-model="invoiceData.company_name"
                  type="text"
                  placeholder="Firmenname (optional)"
                  class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                >
              </div>
              
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">Kontaktperson *</label>
                <input
                  v-model="invoiceData.contact_person"
                  type="text"
                  required
                  placeholder="Vorname Nachname"
                  class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                >
              </div>
              
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">E-Mail *</label>
                <input
                  v-model="invoiceData.email"
                  type="email"
                  required
                  placeholder="email@beispiel.ch"
                  class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                >
              </div>
              
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">Telefon</label>
                <input
                  v-model="invoiceData.phone"
                  type="tel"
                  placeholder="+41 44 123 45 67"
                  class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                >
              </div>
              
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">Straße & Hausnummer *</label>
                <div class="grid grid-cols-3 gap-2">
                  <input
                    v-model="invoiceData.street"
                    type="text"
                    required
                    placeholder="Musterstraße"
                    class="col-span-2 px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                  >
                  <input
                    v-model="invoiceData.street_number"
                    type="text"
                    required
                    placeholder="123"
                    class="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                  >
                </div>
              </div>
              
              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="block text-xs font-medium text-gray-600 mb-1">PLZ *</label>
                  <input
                    v-model="invoiceData.zip"
                    type="text"
                    required
                    placeholder="8000"
                    class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                  >
                </div>
                <div>
                  <label class="block text-xs font-medium text-gray-600 mb-1">Ort *</label>
                  <input
                    v-model="invoiceData.city"
                    type="text"
                    required
                    placeholder="Zürich"
                    class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                  >
                </div>
              </div>
              
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">Land</label>
                <input
                  v-model="invoiceData.country"
                  type="text"
                  placeholder="Schweiz"
                  class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                >
              </div>
              
              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="block text-xs font-medium text-gray-600 mb-1">MWST-Nummer</label>
                  <input
                    v-model="invoiceData.vat_number"
                    type="text"
                    placeholder="CHE-123.456.789"
                    class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                  >
                </div>
                <div>
                  <label class="block text-xs font-medium text-gray-600 mb-1">Handelsregisternummer</label>
                  <input
                    v-model="invoiceData.company_register_number"
                    type="text"
                    placeholder="CH-123.456.789"
                    class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                  >
                </div>
              </div>
              
              <div>
                <label class="block text-xs font-medium text-gray-600 mb-1">Notizen</label>
                <textarea
                  v-model="invoiceData.notes"
                  placeholder="Zusätzliche Informationen..."
                  rows="2"
                  class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-black bg-white"
                ></textarea>
              </div>
              
              <div class="flex gap-2">
                <button
                  type="button"
                  @click="saveInvoiceAddress"
                  :disabled="!isInvoiceFormValid || isSavingInvoice"
                  class="flex-1 px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <span v-if="isSavingInvoice">💾 Speichere...</span>
                  <span v-else>💾 {{ isEditingBillingAddress ? 'Änderungen speichern' : 'Rechnungsadresse speichern' }}</span>
                </button>
                
                <!-- Abbrechen-Button nur im Bearbeitungsmodus -->
                <button
                  v-if="isEditingBillingAddress"
                  type="button"
                  @click="cancelEditingBillingAddress"
                  class="px-4 py-2 bg-gray-500 text-white text-sm font-medium rounded-md hover:bg-gray-600"
                >
                  ❌ Abbrechen
                </button>
              </div>
              
              <div v-if="invoiceSaveMessage" class="text-sm text-center p-2 rounded-md" :class="invoiceSaveMessage.type === 'success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'">
                {{ invoiceSaveMessage.text }}
              </div>
            </div>
          </div>
      </div>
    </div>






  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { usePaymentMethods, useCompanyBilling } from '~/composables/usePaymentMethods'
import { useEventModalForm } from '~/composables/useEventModalForm'
import { getSupabase } from '~/utils/supabase'
import { watch } from 'vue'

// Erweiterte Props
interface Props {
  durationMinutes: number
  pricePerMinute: number
  selectedStudent?: any
  discount?: number
  discountReason?: string
  allowDiscountEdit?: boolean
  allowProductEdit?: boolean
  lessonType?: string
  debugInfo?: string
  products?: any[]
  availableProducts?: any[]
  isPastAppointment?: boolean
  currentUser?: any
  adminFee?: number // ✅ NEU: Admin-Fee in CHF
  showAdminFee?: boolean // ✅ NEU: Ob Admin-Fee angezeigt werden soll
  selectedPaymentMethod?: string // ✅ NEU: Selected payment method von EventModal
  isEditMode?: boolean // ✅ NEU: Ob im Edit-Modus (bestehender Termin)
  appointmentId?: string // ✅ NEU: Appointment ID für Payment-Daten laden
  studentCredit?: any // ✅ NEU: Student credit information
  isLoadingCredit?: boolean // ✅ NEU: Loading state for credit
}

const props = withDefaults(defineProps<Props>(), {
  discount: 0,
  discountReason: '',
  allowDiscountEdit: true,
  allowProductEdit: true,
  products: () => [],
  availableProducts: () => [],
  isPastAppointment: false,
  adminFee: 0,
  showAdminFee: false,
  selectedPaymentMethod: 'wallee',
  isEditMode: false,
  appointmentId: undefined,
  studentCredit: undefined,
  isLoadingCredit: false
})

// Emits
const emit = defineEmits<{
  'discount-changed': [discount: number, discountType: "fixed", reason: string]
  'product-removed': [productId: string]
  'product-added': [product: any]
  'payment-method-changed': [method: string]
  'invoice-address-saved': [address: any]

  'update:selectedPaymentMethod': [value: string] // ✅ NEU: v-model emit für payment method
}>()

// Composables
const { loadPaymentMethods, activePaymentMethods, isLoading: isLoadingPaymentMethods } = usePaymentMethods()
const { createBillingAddress } = useCompanyBilling()

// Computed Properties
const isStaffUser = computed(() => {
  // Prüfe ob der aktuelle Benutzer Staff oder Admin ist
  return props.currentUser?.role === 'staff' || props.currentUser?.role === 'admin'
})

// State
const showProductSelector = ref(false)
const showDiscountSelector = ref(false) // ✅ NEU: Für Gutschein-Auswahl
const availableDiscounts = ref<any[]>([]) // ✅ NEU: Verfügbare Gutscheine
const isLoadingDiscounts = ref(false) // ✅ NEU: Loading state für Gutscheine

// ✅ NEU: Payment State für Edit-Modus
const existingPayment = ref<any>(null)
const isLoadingPayment = ref(false)
// ✅ NEU: State für Student Billing Address Management
const studentBillingAddress = ref<any>(null)
const isLoadingStudentBilling = ref(false)
const isEditingBillingAddress = ref(false)

// ✅ NEU: Company Billing Address ID (wird gesetzt, wenn Rechnungsadresse gespeichert wird)
const savedCompanyBillingAddressId = ref<string | null>(null)

// ✅ Computed: Use prop for selectedPaymentMethod
const selectedPaymentMethod = computed({
  get: () => props.selectedPaymentMethod || 'wallee',
  set: (value: string) => emit('update:selectedPaymentMethod', value)
})

// ✅ Computed: Check if invoice address exists
const hasInvoiceAddress = computed(() => {
  const payment = existingPayment.value
  if (!payment) return false
  
  // Check if there's a company billing address (preferred)
  if (payment.company_billing_address && typeof payment.company_billing_address === 'object') {
    return true
  }
  
  // Fallback: Check JSONB invoice_address field
  return payment.invoice_address && 
         typeof payment.invoice_address === 'object' &&
         Object.keys(payment.invoice_address).length > 0
})

// ✅ Function: Format invoice address for display
const formatInvoiceAddress = (): string => {
  const payment = existingPayment.value
  if (!payment) return 'Keine Rechnungsadresse gespeichert'
  
  let invoiceAddr = null
  
  // Prefer company billing address (new structure with single object)
  if (payment.company_billing_address && typeof payment.company_billing_address === 'object') {
    invoiceAddr = payment.company_billing_address
  }
  // Fallback to JSONB invoice_address
  else if (payment.invoice_address && typeof payment.invoice_address === 'object') {
    invoiceAddr = payment.invoice_address
  }
  
  if (!invoiceAddr) {
    return 'Keine Rechnungsadresse gespeichert'
  }
  
  const lines = []
  
  if (invoiceAddr.company_name) {
    lines.push(invoiceAddr.company_name)
  }
  
  if (invoiceAddr.contact_person) {
    lines.push(invoiceAddr.contact_person)
  }
  
  if (invoiceAddr.street && invoiceAddr.street_number) {
    lines.push(`${invoiceAddr.street} ${invoiceAddr.street_number}`)
  } else if (invoiceAddr.street) {
    lines.push(invoiceAddr.street)
  }
  
  if (invoiceAddr.zip && invoiceAddr.city) {
    lines.push(`${invoiceAddr.zip} ${invoiceAddr.city}`)
  }
  
  if (invoiceAddr.country && invoiceAddr.country !== 'Schweiz') {
    lines.push(invoiceAddr.country)
  }
  
  if (invoiceAddr.email) {
    lines.push(`E-Mail: ${invoiceAddr.email}`)
  }
  
  if (invoiceAddr.phone) {
    lines.push(`Tel: ${invoiceAddr.phone}`)
  }
  
  if (invoiceAddr.vat_number) {
    lines.push(`UID: ${invoiceAddr.vat_number}`)
  }
  
  return lines.join('\n') || 'Keine Adressdaten verfügbar'
}

// ✅ NEU: Manueller Rabatt State
const manualDiscountAmount = ref<number>(0)
const manualDiscountReason = ref<string>('')

// Rechnungsadresse State
const invoiceData = ref({
  company_name: '',
  contact_person: '',
  email: '',
  phone: '',
  street: '',
  street_number: '',
  zip: '',
  city: '',
  country: 'Schweiz',
  vat_number: '',
  company_register_number: '',
  notes: ''
})

const isSavingInvoice = ref(false)
const invoiceSaveMessage = ref<{ type: 'success' | 'error', text: string } | null>(null)

// Lifecycle
onMounted(async () => {
  console.log('🚀 PriceDisplay mounted, starting to load data...')
  
  await Promise.all([
    loadPaymentMethods(),
    loadAvailableDiscounts(), // ✅ Lade verfügbare Gutscheine
    loadExistingPayment() // ✅ NEU: Payment-Daten laden
  ])
  
  // ✅ NEU: Student Billing Address laden (falls Student bereits ausgewählt)
  if (props.selectedStudent?.id) {
    console.log('🏢 PriceDisplay onMounted: Loading billing address for student:', props.selectedStudent.id)
    await loadStudentBillingAddressData(props.selectedStudent.id)
    
    // ✅ ZUSÄTZLICH: Falls kein Student Billing gefunden, versuche über bestehende Payments zu laden
    if (!studentBillingAddress.value) {
      await loadBillingAddressFromExistingPayments(props.selectedStudent.id)
    }
  } else {
    console.log('💡 PriceDisplay onMounted: No student selected yet')
  }
  
  console.log('✅ PriceDisplay initialization complete')
})

// ✅ NEU: Watcher für Student-Änderung - lädt automatisch Billing Address
watch(() => props.selectedStudent?.id, async (newStudentId: string, oldStudentId: string) => {
  if (newStudentId && newStudentId !== oldStudentId) {
    console.log('👤 Student changed, loading billing address for:', newStudentId)
    await loadStudentBillingAddressData(newStudentId)
    
    // ✅ Fallback: Falls keine direkte Student Billing Address gefunden
    if (!studentBillingAddress.value) {
      await loadBillingAddressFromExistingPayments(newStudentId)
    }
  }
}, { immediate: false })

// ✅ NEUE METHODE: Lade verfügbare Gutscheine
const loadAvailableDiscounts = async () => {
  try {
    console.log('🔄 Starting to load available discounts...')
    isLoadingDiscounts.value = true
    const supabase = getSupabase()
    
    console.log('🔍 Querying discounts table for fixed discounts...')
    
    // ✅ Lade nur Gutscheine mit discount_type = 'fixed'
    const { data, error } = await supabase
      .from('discounts')
      .select('*')
      .eq('is_active', true)
      .eq('discount_type', 'fixed')
      .order('discount_value', { ascending: true })
    
    if (error) {
      console.error('❌ Error loading discounts:', error)
      return
    }
    
    console.log('📊 Raw discounts data:', data)
    console.log('📊 Fixed discounts found:', data)
    
    availableDiscounts.value = data || []
    console.log('✅ Loaded available fixed discounts:', availableDiscounts.value.length)
    console.log('🎫 Available discounts:', availableDiscounts.value)
    
  } catch (err: any) {
    console.error('❌ Error loading discounts:', err)
  } finally {
    isLoadingDiscounts.value = false
  }
}

// Methods
const applyVoucher = (discount: any) => {
  const discountValue = parseFloat(discount.discount_value) || 0
  if (discountValue > 0) {
    emit('discount-changed', discountValue, discount.discount_type || 'fixed', discount.name)
    showDiscountSelector.value = false
    console.log('✅ Applied voucher:', discount.name, 'Value:', discountValue)
  }
}

// ✅ NEUE METHODE: Manuellen Rabatt anwenden
const applyManualDiscount = () => {
  if (!manualDiscountAmount.value || manualDiscountAmount.value <= 0) return
  
  const reason = manualDiscountReason.value || 'Manueller Rabatt'
  emit('discount-changed', manualDiscountAmount.value, 'fixed', reason)
  
  // Reset form
  manualDiscountAmount.value = 0
  manualDiscountReason.value = ''
  showDiscountSelector.value = false
  
  console.log('✅ Applied manual discount:', manualDiscountAmount.value, 'Reason:', reason)
}

// ✅ NEUE METHODE: Gutschein-Selector schließen
const closeDiscountSelector = () => {
  showDiscountSelector.value = false
  // Reset manual discount form
  manualDiscountAmount.value = 0
  manualDiscountReason.value = ''
}

const removeDiscount = () => {
  emit('discount-changed', 0, 'fixed', '')
}

const removeProduct = (productId: string) => {
  emit('product-removed', productId)
}

// ✅ NEU: Base Price aus bestehender Payment oder berechnet
const getBasePrice = () => {
  // Im Edit-Modus: Verwende den gespeicherten Preis aus der Payment-Tabelle
  if (props.isEditMode && existingPayment.value) {
    return (existingPayment.value.lesson_price_rappen || 0) / 100
  }
  
  // Im Create-Modus: Berechne den Preis neu
  return props.durationMinutes * props.pricePerMinute
}

// ✅ NEU: Discount Amount aus bestehender Payment oder Props
const getDiscountAmount = () => {
  // Im Edit-Modus: Verwende den gespeicherten Rabatt aus der Payment-Tabelle
  if (props.isEditMode && existingPayment.value) {
    return (existingPayment.value.discount_amount_rappen || 0) / 100
  }
  
  // Im Create-Modus: Verwende Props
  return props.discount || 0
}

// ✅ NEU: Discount Reason aus bestehender Payment oder Props
const getDiscountReason = () => {
  // Im Edit-Modus: Verwende den gespeicherten Rabatt-Grund aus der Payment-Tabelle
  if (props.isEditMode && existingPayment.value) {
    return existingPayment.value.discount_reason || ''
  }
  
  // Im Create-Modus: Verwende Props
  return props.discountReason || ''
}

// ✅ NEU: Products aus bestehender Payment oder Props
const getProducts = () => {
  // Im Edit-Modus: verwende ausschließlich die geladenen Produkte der Payment
  if (props.isEditMode) {
    return (existingPayment.value && (existingPayment.value as any).products) ? (existingPayment.value as any).products : []
  }
  
  // Im Create-Modus: Verwende Props
  return props.products || []
}

// ✅ NEU: Admin Fee aus bestehender Payment oder Props
const getAdminFee = () => {
  // Im Edit-Modus: Verwende den gespeicherten Admin-Fee aus der Payment-Tabelle
  if (props.isEditMode && existingPayment.value) {
    return (existingPayment.value.admin_fee_rappen || 0) / 100
  }
  
  // Im Create-Modus: Verwende Props
  return (props.showAdminFee && props.adminFee) ? props.adminFee : 0
}

// ✅ NEU: Used Credit aus bestehender Payment oder Props
const getUsedCredit = () => {
  // Im Edit-Modus: Verwende das gespeicherte verwendete Guthaben aus der Payment-Tabelle
  if (props.isEditMode && existingPayment.value) {
    // Primär: explizit gespeicherter Wert
    const fromPayment = existingPayment.value.credit_used_rappen
    if (typeof fromPayment === 'number' && fromPayment > 0) {
      return fromPayment / 100
    }

    // Fallback: aus verknüpfter Kredit-Transaktion ableiten
    const tx = (existingPayment.value as any).credit_transaction
    if (tx && typeof tx.amount_rappen === 'number') {
      // Verwende den absoluten Betrag (Transaktionsrichtung kann variieren)
      return Math.abs(tx.amount_rappen) / 100
    }

    return 0
  }
  
  // Im Create-Modus: Berechne das verwendete Guthaben basierend auf dem aktuellen Guthaben
  if (props.studentCredit && props.studentCredit.balance_rappen > 0) {
    const creditAmount = props.studentCredit.balance_rappen / 100
    const totalBeforeCredit = calculatePriceBeforeCredit()
    return Math.min(creditAmount, totalBeforeCredit)
  }
  
  return 0
}

const calculateTotalPrice = () => {
  const basePrice = getBasePrice()
  const discountAmount = getDiscountAmount()
  const productsTotal = getProducts().reduce((total, product) => {
    return total + getProductPrice(product)
  }, 0)
  const adminFeeAmount = getAdminFee()
  const usedCredit = getUsedCredit()
  
  const totalBeforeCredit = basePrice - discountAmount + productsTotal + adminFeeAmount
  
  // Guthaben abziehen (entweder aus Payment-Tabelle oder aktuelles Guthaben)
  return Math.max(0, totalBeforeCredit - usedCredit)
}

const calculatePriceBeforeCredit = () => {
  const basePrice = getBasePrice()
  const discountAmount = getDiscountAmount()
  const productsTotal = getProducts().reduce((total, product) => {
    return total + getProductPrice(product)
  }, 0)
  const adminFeeAmount = getAdminFee()
  
  return basePrice - discountAmount + productsTotal + adminFeeAmount
}

const addProduct = (product: any) => {
  // Füge das Produkt zu den ausgewählten Produkten hinzu
  const existingProduct = props.products?.find(p => p.id === product.id)
  
  if (existingProduct) {
    // Produkt bereits vorhanden - Menge erhöhen
    existingProduct.quantity = (existingProduct.quantity || 1) + 1
  } else {
    // Neues Produkt hinzufügen
    emit('product-added', { 
      ...product, 
      quantity: 1,
      price: product.price_rappen / 100 // Konvertiere zu CHF
    })
  }
  
  // Modal nach dem Hinzufügen schließen
  showProductSelector.value = false
}

const getProductPrice = (product: any): number => {
  // Sichere Preisberechnung - unterstützt sowohl price als auch price_rappen
  if (product.price !== undefined) {
    return product.price * (product.quantity || 1)
  } else if (product.price_rappen !== undefined) {
    return (product.price_rappen / 100) * (product.quantity || 1)
  }
  return 0
}

const selectPaymentMethod = (method: string) => {
  selectedPaymentMethod.value = method
  emit('payment-method-changed', method)
  console.log('💳 PriceDisplay - Payment method selected:', method)
  
  // ✅ Debug: Zeige den aktuellen Zustand wenn 'invoice' gewählt wird
  if (method === 'invoice') {
    console.log('📋 Invoice selected - current state:', {
      selectedStudent: props.selectedStudent?.id,
      studentBillingAddress: !!studentBillingAddress.value,
      existingPayment: !!existingPayment.value,
      isEditMode: props.isEditMode
    })
  }
}

// ✅ NEU: Load billing address from existing payments (fallback method)
const loadBillingAddressFromExistingPayments = async (studentId: string) => {
  if (!studentId) return null
  
  try {
    console.log('🔍 Fallback: Loading billing address from existing payments for student:', studentId)
    
    const supabase = getSupabase()
    const { data: paymentData, error } = await supabase
      .from('payments')
      .select(`
        company_billing_address_id,
        company_billing_address:company_billing_addresses!company_billing_address_id (
          id,
          company_name,
          contact_person,
          email,
          phone,
          street,
          street_number,
          zip,
          city,
          country,
          vat_number,
          notes
        )
      `)
      .eq('user_id', studentId)
      .eq('payment_method', 'invoice')
      .not('company_billing_address_id', 'is', null)
      .order('created_at', { ascending: false })
      .limit(1)
      .single()

    if (error) {
      if (error.code === 'PGRST116') {
        console.log('💡 No existing invoice payments with billing address found')
        return null
      }
      throw error
    }

    if (paymentData?.company_billing_address) {
      studentBillingAddress.value = paymentData.company_billing_address
      console.log('✅ Billing address loaded from existing payment:', paymentData.company_billing_address)
      return paymentData.company_billing_address
    }
    
    return null
  } catch (error) {
    console.error('❌ Error loading billing address from payments:', error)
    return null
  }
}

// ✅ NEU: Load student billing address for new appointments or editing
const loadStudentBillingAddressData = async (studentId: string) => {
  if (!studentId) return null
  
  try {
    isLoadingStudentBilling.value = true
    console.log('🏢 Loading student billing address for PriceDisplay:', studentId)
    
    const modalForm = useEventModalForm()
    const billingData = await modalForm.loadStudentBillingAddress(studentId)
    
    if (billingData) {
      studentBillingAddress.value = billingData
      console.log('✅ Student billing address loaded in PriceDisplay:', billingData)
    }
    
    return billingData
  } catch (error) {
    console.error('❌ Error loading student billing address:', error)
    return null
  } finally {
    isLoadingStudentBilling.value = false
  }
}

// ✅ NEU: Funktionen für Rechnungsadresse-Bearbeitung
const startEditingBillingAddress = () => {
  isEditingBillingAddress.value = true
  
  // ✅ NEU: Stelle sicher, dass wir die bestehende Adresse haben
  const existingAddress = studentBillingAddress.value || existingPayment.value?.company_billing_address
  
  if (existingAddress) {
    console.log('✏️ Loading existing address data for editing:', existingAddress.id || 'no-id')
    
    invoiceData.value = {
      company_name: existingAddress.company_name || '',
      contact_person: existingAddress.contact_person || '',
      email: existingAddress.email || '',
      phone: existingAddress.phone || '',
      street: existingAddress.street || '',
      street_number: existingAddress.street_number || '',
      zip: existingAddress.zip || '',
      city: existingAddress.city || '',
      country: existingAddress.country || 'Schweiz',
      vat_number: existingAddress.vat_number || '',
      company_register_number: existingAddress.company_register_number || '',
      notes: existingAddress.notes || ''
    }
  } else {
    console.log('⚠️ No existing address found for editing')
  }
  
  console.log('✏️ Started editing billing address')
}

const cancelEditingBillingAddress = () => {
  isEditingBillingAddress.value = false
  // Formular zurücksetzen
  invoiceData.value = {
    company_name: '',
    contact_person: '',
    email: '',
    phone: '',
    street: '',
    street_number: '',
    zip: '',
    city: '',
    country: 'Schweiz',
    vat_number: '',
    company_register_number: '',
    notes: ''
  }
  console.log('❌ Cancelled editing billing address')
}

// ✅ NEU: Load existing payment data
const loadExistingPayment = async () => {
  console.log('🔍 loadExistingPayment check:', {
    appointmentId: props.appointmentId,
    isEditMode: props.isEditMode,
    shouldLoad: !!(props.appointmentId && props.isEditMode)
  })
  
  if (!props.appointmentId || !props.isEditMode) {
    console.log('⏭️ Skipping payment loading - no appointmentId or not in edit mode')
    return
  }
  
  // 🔄 Reset state to avoid leaking previous appointment data
  existingPayment.value = null
  
  isLoadingPayment.value = true
  try {
    const supabase = getSupabase()
    const { data: paymentData, error } = await supabase
      .from('payments')
      .select(`
        *,
        company_billing_address:company_billing_addresses!company_billing_address_id (
          id,
          company_name,
          contact_person,
          email,
          phone,
          street,
          street_number,
          zip,
          city,
          country,
          vat_number,
          notes
        ),
        credit_transaction:credit_transactions!credit_transaction_id (
          id,
          amount_rappen,
          transaction_type,
          notes
        )
      `)
      .eq('appointment_id', props.appointmentId)
      .single()
    
    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
      console.warn('⚠️ PriceDisplay - Error loading payment data:', error)
      return
    }
    
    if (paymentData) {
      // Initialize with empty products array to avoid stale data
      existingPayment.value = { ...paymentData, products: [] }
      console.log('✅ PriceDisplay - Existing payment loaded:', {
        payment_method: paymentData.payment_method,
        payment_status: paymentData.payment_status,
        total_chf: (paymentData.total_amount_rappen / 100).toFixed(2),
        invoice_address: paymentData.invoice_address ? 'JSONB vorhanden' : 'JSONB nicht vorhanden',
        company_billing_address_id: paymentData.company_billing_address_id,
        company_billing_address: paymentData.company_billing_address ? 'Joined vorhanden' : 'Joined nicht vorhanden',
        paid_at: paymentData.paid_at
      })

      // 🔗 Produkte für genau diesen Termin laden (discount_sales -> product_sales)
      try {
        console.log('📦 Loading existing products for appointment:', props.appointmentId)
        const { data: discountSale, error: dsError } = await supabase
          .from('discount_sales')
          .select('id')
          .eq('appointment_id', props.appointmentId as string)
          .single()

        if (!dsError && discountSale?.id) {
          const { data: productsData, error: psError } = await supabase
            .from('product_sales')
            .select(`
              id,
              quantity,
              unit_price_rappen,
              total_price_rappen,
              products (
                name,
                description
              )
            `)
            .eq('discount_sale_id', discountSale.id)

          if (!psError && Array.isArray(productsData)) {
            const mapped = productsData.map(p => ({
              id: p.id,
              name: p.products?.name || 'Produkt',
              description: p.products?.description || '',
              quantity: p.quantity || 1,
              price_rappen: typeof p.unit_price_rappen === 'number' ? p.unit_price_rappen : undefined,
              total_price_rappen: typeof p.total_price_rappen === 'number' ? p.total_price_rappen : undefined,
              price: undefined
            }))
            ;(existingPayment.value as any).products = mapped
            console.log('📦 PriceDisplay - Loaded appointment products:', mapped.length)
          } else {
            // Ensure products cleared if query returns nothing
            ;(existingPayment.value as any).products = []
            console.log('📦 PriceDisplay - No products for this appointment')
          }
        } else {
          // No discount sale => no products
          ;(existingPayment.value as any).products = []
          console.log('📦 PriceDisplay - No discount_sale found for this appointment')
        }
      } catch (prodErr) {
        // On error, still ensure products are empty
        ;(existingPayment.value as any).products = []
        console.warn('⚠️ PriceDisplay - Could not load appointment products:', prodErr)
      }
    }
  } catch (err) {
    console.error('❌ PriceDisplay - Error loading payment:', err)
  } finally {
    isLoadingPayment.value = false
  }
}

// ✅ Computed: Soll Zahlungsauswahl angezeigt werden?
const showPaymentSelection = computed(() => {
  // Im Edit-Modus nur anzeigen wenn kein Payment existiert
  if (props.isEditMode) {
    return !existingPayment.value
  }
  // Im CREATE-Modus immer anzeigen
  return true
})

// ✅ Computed: Soll bestehende Payment-Info angezeigt werden?
const showExistingPaymentInfo = computed(() => {
  return props.isEditMode && existingPayment.value
})

// ✅ NEU: Computed für Rechnungsadresse-Anzeige vs. Formular
const shouldShowBillingAddressForm = computed(() => {
  const isInvoiceSelected = selectedPaymentMethod.value === 'invoice'
  const hasPaymentSelection = showPaymentSelection.value
  const hasNoSavedAddress = !studentBillingAddress.value && !existingPayment.value?.company_billing_address
  const isExplicitlyEditing = isEditingBillingAddress.value
  
  const result = isInvoiceSelected && hasPaymentSelection && (hasNoSavedAddress || isExplicitlyEditing)
  
  console.log('📝 shouldShowBillingAddressForm check:', {
    isInvoiceSelected,
    hasPaymentSelection,
    hasNoSavedAddress,
    isExplicitlyEditing,
    result
  })
  
  return result
})

// ✅ NEU: Computed für die Anzeige der gespeicherten Rechnungsadresse
const shouldShowSavedBillingAddress = computed(() => {
  const isInvoiceSelected = selectedPaymentMethod.value === 'invoice'
  const hasStudentBilling = !!studentBillingAddress.value
  const hasExistingPaymentBilling = !!existingPayment.value?.company_billing_address
  const isNotEditing = !isEditingBillingAddress.value
  
  const result = isInvoiceSelected && (hasStudentBilling || hasExistingPaymentBilling) && isNotEditing
  
  console.log('🔍 shouldShowSavedBillingAddress check:', {
    isInvoiceSelected,
    hasStudentBilling,
    hasExistingPaymentBilling,
    isNotEditing,
    existingPaymentData: existingPayment.value ? {
      company_billing_address_id: existingPayment.value.company_billing_address_id,
      hasCompanyBillingAddress: !!existingPayment.value.company_billing_address
    } : null,
    result
  })
  
  return result
})

// Computed für Rechnungsform-Validierung
const isInvoiceFormValid = computed(() => {
  return invoiceData.value.contact_person && 
         invoiceData.value.email && 
         invoiceData.value.street && 
         invoiceData.value.street_number && 
         invoiceData.value.zip && 
         invoiceData.value.city
})

// Rechnungsadresse speichern
const saveInvoiceAddress = async () => {
  if (!isInvoiceFormValid.value) return
  
  isSavingInvoice.value = true
  invoiceSaveMessage.value = null
  
  try {
    // Hole den aktuellen Benutzer für created_by
    const supabase = getSupabase()
    const { data: { user } } = await supabase.auth.getUser()
    const currentUserId = user?.id
    
    if (!currentUserId) {
      throw new Error('Benutzer nicht angemeldet')
    }
    
    let result
    
    // ✅ NEU: Falls wir im Bearbeitungsmodus sind, UPDATE statt INSERT
    if (isEditingBillingAddress.value && studentBillingAddress.value?.id) {
      console.log('✏️ Updating existing billing address:', studentBillingAddress.value.id)
      
      const updateData = {
        ...invoiceData.value,
        updated_at: new Date().toISOString()
      }
      
      const { data, error } = await supabase
        .from('company_billing_addresses')
        .update(updateData)
        .eq('id', studentBillingAddress.value.id)
        .select()
        .single()
      
      if (error) {
        throw new Error(`Update failed: ${error.message}`)
      }
      
      result = { success: true, data }
      console.log('✅ Billing address updated successfully')
      
    } else {
      // ✅ NEU: Neuen Eintrag erstellen
      console.log('➕ Creating new billing address')
      
      const addressData = {
        ...invoiceData.value,
        created_by: currentUserId,
        is_active: true,
        is_verified: false
      }
      
      result = await createBillingAddress(addressData)
    }
    
          if (result.success) {
        // ✅ NEU: Speichere die company_billing_address_id
        savedCompanyBillingAddressId.value = result.data?.id || null
        console.log('✅ Company billing address ID saved:', result.data?.id)
        
        // ✅ NEU: Unterscheide zwischen Update und Create für die Nachricht
        const isUpdate = isEditingBillingAddress.value
        invoiceSaveMessage.value = {
          type: 'success',
          text: isUpdate ? '✅ Rechnungsadresse erfolgreich aktualisiert!' : '✅ Rechnungsadresse erfolgreich gespeichert!'
        }
        
        // Emit an Parent Component
        emit('invoice-address-saved', result.data)
        
        // ✅ NEU: Update studentBillingAddress und exit edit mode
        studentBillingAddress.value = result.data
        isEditingBillingAddress.value = false
        
        // Form zurücksetzen
        setTimeout(() => {
          invoiceSaveMessage.value = null
        }, 3000)
        
      } else {
        throw new Error(result.error || 'Unbekannter Fehler')
      }
    
  } catch (err: any) {
    console.error('❌ Error saving invoice address:', err)
    invoiceSaveMessage.value = {
      type: 'error',
      text: `❌ Fehler beim Speichern: ${err.message}`
    }
  } finally {
    isSavingInvoice.value = false
  }
}


</script>
