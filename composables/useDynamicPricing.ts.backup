// composables/usePricing.ts
import { ref, computed } from 'vue'
import { getSupabase } from '~/utils/supabase'
import { toLocalTimeString } from '~/utils/dateUtils'

interface PricingRule {
  id: string
  category_code: string
  price_per_minute_rappen: number
  admin_fee_rappen: number
  admin_fee_applies_from: number
  base_duration_minutes: number
  is_active: boolean
  rule_name: string
  valid_from: string | null
  valid_until: string | null
}

interface CalculatedPrice {
  base_price_rappen: number
  admin_fee_rappen: number
  total_rappen: number
  base_price_chf: string
  admin_fee_chf: string
  total_chf: string
  category_code: string
  duration_minutes: number
  appointment_number: number
}

export const usePricing = () => {
  const supabase = getSupabase()
  
  // State
  const pricingRules = ref<PricingRule[]>([])
  const isLoadingPrices = ref(false)
  const pricingError = ref<string>('')
  const lastLoaded = ref<Date | null>(null)
  
  // Cache f√ºr 5 Minuten
  const CACHE_DURATION = 5 * 60 * 1000

  // Load pricing rules from database
  const loadPricingRules = async (forceReload = false): Promise<void> => {
    console.log('üîÑ Loading pricing rules from database...')
    
    // Pr√ºfe Cache
    if (!forceReload && lastLoaded.value && 
        (Date.now() - lastLoaded.value.getTime()) < CACHE_DURATION) {
      console.log('üì¶ Using cached pricing rules')
      return
    }

    isLoadingPrices.value = true
    pricingError.value = ''

    try {
      const { data, error } = await supabase
        .from('pricing_rules')
        .select('*')
        .eq('rule_type', 'category_pricing')
        .eq('is_active', true)
        .order('category_code')

      console.log('üìä Database response:', { data, error })

      if (error) {
        console.error('‚ùå Database error:', error)
        throw new Error(`Database error: ${error.message}`)
      }

      if (!data || data.length === 0) {
        console.warn('‚ö†Ô∏è No pricing rules found, using fallback')
        await createFallbackPricingRules()
        return
      }

      // Filter nur g√ºltige Regeln
      const today = toLocalTimeString(new Date).split('T')[0]
      const validRules = data.filter(rule => {
        const validFrom = rule.valid_from || '1900-01-01'
        const validUntil = rule.valid_until || '2099-12-31'
        return today >= validFrom && today <= validUntil
      })

      pricingRules.value = validRules
      lastLoaded.value = new Date()

      console.log('‚úÖ Pricing rules loaded:', validRules.length, 'rules')
      console.log('üìä Categories:', validRules.map(r => r.category_code))

    } catch (err: any) {
      console.error('‚ùå Error loading pricing rules:', err)
      pricingError.value = err.message || 'Fehler beim Laden der Preisregeln'
      
      // Fallback auf hard-coded Werte bei Fehler
      await createFallbackPricingRules()
    } finally {
      isLoadingPrices.value = false
    }
  }

  // Fallback: Hard-coded Werte in Memory laden
  const createFallbackPricingRules = async (): Promise<void> => {
    console.log('üîÑ Using fallback pricing rules...')
    
    const fallbackRules: PricingRule[] = [
      { 
        id: 'fallback-B', 
        category_code: 'B', 
        price_per_minute_rappen: 211, 
        admin_fee_rappen: 12000, 
        admin_fee_applies_from: 2, 
        base_duration_minutes: 45, 
        is_active: true, 
        valid_from: null, 
        valid_until: null, 
        rule_name: 'Fallback B' 
      },
      { 
        id: 'fallback-A1', 
        category_code: 'A1', 
        price_per_minute_rappen: 211, 
        admin_fee_rappen: 12000, 
        admin_fee_applies_from: 2, 
        base_duration_minutes: 45, 
        is_active: true, 
        valid_from: null, 
        valid_until: null, 
        rule_name: 'Fallback A1' 
      },
      { 
        id: 'fallback-C', 
        category_code: 'C', 
        price_per_minute_rappen: 333, 
        admin_fee_rappen: 25000, 
        admin_fee_applies_from: 2, 
        base_duration_minutes: 45, 
        is_active: true, 
        valid_from: null, 
        valid_until: null, 
        rule_name: 'Fallback C' 
      }
    ]
    
    pricingRules.value = fallbackRules
    lastLoaded.value = new Date()
    console.log('‚úÖ Fallback pricing rules loaded')
  }

  // Get pricing rule for specific category
  const getPricingRule = (categoryCode: string): PricingRule | null => {
    const rule = pricingRules.value.find(rule => rule.category_code === categoryCode)
    if (!rule) {
      console.warn(`‚ö†Ô∏è No pricing rule found for category: ${categoryCode}`)
      return null
    }
    return rule
  }

  // Get appointment count for user
  const getAppointmentCount = async (userId: string): Promise<number> => {
    try {
      const { count, error } = await supabase
        .from('appointments')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId)
        .in('status', ['completed', 'confirmed'])

      if (error) {
        console.error('‚ùå Error counting appointments:', error)
        return 1
      }

      return (count || 0) + 1
    } catch (error) {
      console.error('‚ùå Error in getAppointmentCount:', error)
      return 1
    }
  }

  // Calculate price
  const calculatePrice = async (
    categoryCode: string,
    durationMinutes: number,
    userId?: string
  ): Promise<CalculatedPrice> => {
    // Lade Pricing Rules falls noch nicht geladen
    if (pricingRules.value.length === 0) {
      await loadPricingRules()
    }

    const rule = getPricingRule(categoryCode)
    if (!rule) {
      throw new Error(`Keine Preisregel f√ºr Kategorie ${categoryCode} gefunden`)
    }

    // Appointment count ermitteln
    const appointmentNumber = userId ? await getAppointmentCount(userId) : 1

    // Grundpreis berechnen
    const basePriceRappen = Math.round(rule.price_per_minute_rappen * durationMinutes)
    
    // Admin-Fee nur ab entsprechendem Termin
    const adminFeeRappen = appointmentNumber >= rule.admin_fee_applies_from ? rule.admin_fee_rappen : 0
    
    // Gesamtpreis
    const totalRappen = basePriceRappen + adminFeeRappen

    const result: CalculatedPrice = {
      base_price_rappen: basePriceRappen,
      admin_fee_rappen: adminFeeRappen,
      total_rappen: totalRappen,
      base_price_chf: (basePriceRappen / 100).toFixed(2),
      admin_fee_chf: (adminFeeRappen / 100).toFixed(2),
      total_chf: (totalRappen / 100).toFixed(2),
      category_code: categoryCode,
      duration_minutes: durationMinutes,
      appointment_number: appointmentNumber
    }

    return result
  }

  // Computed
  const isLoaded = computed(() => pricingRules.value.length > 0)
  const categoriesCount = computed(() => pricingRules.value.length)
  const availableCategories = computed(() => 
    pricingRules.value.map(rule => rule.category_code).sort()
  )

  return {
    // State
    pricingRules,
    isLoadingPrices,
    pricingError,
    isLoaded,
    categoriesCount,
    availableCategories,
    
    // Methods
    loadPricingRules,
    calculatePrice,
    getPricingRule,
    getAppointmentCount
  }
}